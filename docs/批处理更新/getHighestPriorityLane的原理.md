举个例子，假设当前的 `lanes` 是 `6`，它的二进制表示是 `0110`。我们需要从中找出优先级最高的那个 lane。根据“越小优先级越高”的原则，我们期望得到最右边的那个“1”所代表的数值，也就是 `0010`（十进制的 2）。

`lanes`: 二进制是 `00000110`

`-lanes`: 计算一个数的负数，计算机采用“二进制补码”法：

1.  **按位取反**：将 `00000110` 的所有位取反，得到 `11111001`。
2.  **加一**：在 `11111001` 的基础上加 1，得到 `11111010`。这就是 `-6` 在内存中的二进制表示。

**进行按位与（`&`）操作**：

```
  00000110  (lanes, 也就是 6)
& 11111010  (-lanes, 也就是 -6)
----------
  00000010  (结果, 也就是 2)
```

可以看到，最终结果 `0010` 成功地将 `0110` 中最右边的（也就是数值最小的）那个 “1” 分离了出来。
