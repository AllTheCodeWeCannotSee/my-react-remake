### 资源到底节省在哪里？

节省的资源主要体现在以下**三个核心方面**：

#### 1. 内存分配与垃圾回收 (Memory & GC)

- **`new FiberNode(...)`**:
  - **消耗**: 每次调用，JavaScript 引擎都需要在内存中**分配一块全新的空间**来存储这个新的 Fiber 对象，并执行其构造函数来初始化所有属性（如 `tag`, `key`, `props`, `stateNode`, `return`, `child`, `sibling`, `alternate` 等）。
  - **后果**: 如果旧的 Fiber 节点被废弃，它就会变成内存垃圾。当垃圾积攒到一定程度，就会触发**垃圾回收（Garbage Collection）**，这会占用 CPU 资源，甚至可能导致页面短暂卡顿。
- **`useFiber(before, ...)`**:
  - **节省**: 它**完全跳过了内存分配**的步骤。它直接拿来了 `before` 这个已经存在的旧 Fiber 对象。内存中没有新对象产生，因此也**减轻了垃圾回收的压力**。

#### 2. 对象初始化成本 (Object Initialization Cost)

- **`new FiberNode(...)`**:
  - **消耗**: 如上所述，构造函数需要运行，将十几个属性一一赋值。虽然单个操作很快，但在一个复杂的页面更新中，成百上千次的调用累加起来，也是一笔不可忽视的 CPU 开销。
- **`useFiber(before, ...)`**:
  - **节省**: `before` 这个旧 Fiber 对象的大部分属性已经是“正确”的了，比如 `key`, `tag`, `alternate` 等。`useFiber` 函数要做的事情非常少，它本质上只是重置了少数几个属性（比如 `pendingProps` 和 `flags`），而不是从零开始创建。这是一个非常轻量级的操作。

#### 3. **【最重要】** DOM 节点的复用 (DOM Node Re-use)

这是**最大、最关键**的资源节省点。

Fiber 节点上有一个非常重要的属性叫 `stateNode`，它直接指向真实的 DOM 节点。

- **`new FiberNode(...)` 的后续**:
  - 当一个 Fiber 节点是**全新创建**的，它上面的 `stateNode` 初始是 `null`。
  - 在后续的“提交（commit）”阶段，React 会发现这是一个新节点（因为它会被打上 `Placement` 的副作用标记），然后会执行 **`document.createTextNode(...)`** 来创建一个全新的文本节点，并将其插入到 DOM 树中。**创建和插入 DOM 节点是非常昂贵的操作**，会引发浏览器的重绘和回流，性能开销很大。
- **`useFiber(before, ...)` 的后续**:
  - `useFiber` 复用了 `before` 这个旧 Fiber 对象，也就意味着它**同时复用了 `before.stateNode`**，即那个已经存在于页面上的真实 DOM 文本节点！
  - 在“提交”阶段，React 看到这个节点只需要更新（它会被打上 `Update` 标记），于是它不会创建新 DOM 节点，而仅仅是执行 **`domElement.nodeValue = 'new content'`** 这样的操作。
  - **更新一个文本节点的内容，比“创建新节点 + 插入新节点 + 删除旧节点”的组合操作要快上几个数量级。**

### 总结

| 对比项   | `new FiberNode` (重建)          | `useFiber` (翻新)         | 资源节省点                |
| :------- | :------------------------------ | :------------------------ | :------------------------ |
| **内存** | **分配新内存**，产生垃圾        | **不分配内存**，无新垃圾  | **内存分配 & GC 压力**    |
| **CPU**  | 运行完整的构造函数              | 仅重置少量属性            | **对象初始化开销**        |
| **DOM**  | 后续需**创建和插入**新 DOM 节点 | 直接**复用**现有 DOM 节点 | **DOM 操作开销 (最关键)** |
