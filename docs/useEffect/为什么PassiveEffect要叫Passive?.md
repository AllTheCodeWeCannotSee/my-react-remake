简单来说，**`Passive` 的意思是“被动的、非阻塞的”**。

它之所以叫 “Passive”（被动），是为了与另一类 “Active”（主动）的副作用（在标准 React 中由 `useLayoutEffect` 实现）形成对比。

- **主动 (Active) 的副作用**：会**立即、同步地**在 DOM 更新后、浏览器绘制前执行。它会“主动”地阻塞渲染流程，确保在用户看到更新的界面之前，相关的操作（如测量 DOM 元素尺寸）已经完成。

- **被动 (Passive) 的副作用 (`useEffect`)**：**不会**立即执行。它会“被动”地等待，直到 React 完成了所有的 DOM 更新，并且浏览器已经将这些更改**绘制到屏幕上**之后，才在一个独立的、稍后的任务中执行。

### 为什么这个“被动”特性如此重要？

因为它保证了**用户界面的流畅性**。

在 `packages/react-reconciler/src/workLoop.ts` 的 `commitRoot` 函数中，我们可以清晰地看到这个设计：

1.  React 完成了所有 DOM 操作。
2.  它检查是否存在带有 `PassiveMask`（包含了`PassiveEffect`）的副作用。
3.  如果存在，它**不会马上执行**，而是调用 `scheduleCallback`。这个函数的作用是：“浏览器，请你在空闲的时候，帮我执行一下 `flushPassiveEffects` 这个任务。”
4.  浏览器接收到这个请求后，会先完成当前最重要的工作——把更新后的 UI 绘制到屏幕上。
5.  在绘制完成后的空闲时间里，浏览器才会回头执行 `flushPassiveEffects`，从而触发 `useEffect` 的回调函数。

### 总结

`PassiveEffect` 中的 **`Passive`** 意味着这个副作用**不会主动阻塞浏览器渲染**。它会“被动地”推迟自己的执行时机，把渲染的优先权完全让给浏览器，从而确保即使用户在 `useEffect` 中执行了耗时操作（如网络请求），也不会导致页面卡顿。这正是 `useEffect` 成为 React 中处理绝大多数副作用的首选方式的原因。
